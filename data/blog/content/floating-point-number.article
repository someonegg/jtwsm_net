IEEE 754浮点数格式备忘
12 Sep 2013
Tags: 浮点数

某某人

* 格式

.image floating-point-number/format.png

	*code*
	单精度 1 + 8  + 23
	双精度 1 + 11 + 52

** 规约形式

	*code*
	a 转成 1.xxx... * 2 ^ n
	尾数的整数部分固定为1
	指数 在 -(2^(e-1) - 2) 到 (2^(e-1) - 1) 之间

** 机器表示

	*code*
	符号 : 0（正） | 1（负）
	指数 : (2^(e-1) - 1) + n
		单精度  127 + [-126  ,  127]
		双精度 1023 + [-1022 , 1023]
	尾数 :
		规约形式第一位的1不存储

** 规则约定

.image floating-point-number/rule.png

** 浮点数表示举例

	*code*
	0.2 = 0  01111111100  1001100110011001100110011001100110011001100110011010
	0.2 = 1/8 + 1/16 + 1/128 + 1/256 + ...
		= 0.00110011...          (二进制)
		= 1.10011... * 2^-3       (二进制)
	符号位0、指数部分 -3 + 1023 = 1020 = 01111111100、尾数部分 10011...

	10 = 0  10000000010  0100000000000000000000000000000000000000000000000000
	10 = 8 + 2
		= 1010
		= 1.010 * 2^3
	符号位0、指数部分 3 + 1023 = 1026 = 10000000010、尾数部分 0100...

可以发现范围之类的整数都能精确表示，但小数很可能不能精确表示。

* 浮点数比较

	*code*
	bool Test()
	{
		double a = 0.2, b = 2, c = 4, d = 1.2;
		double e = (d / a - c) * b + c;
		size_t i = 8;
		double f = (double)i;
		return (f <= e);
	}

浮点数的每次运算都可能产生误差（不能表示就四舍五入等），经过累积最终上面的比较可能会返回 false。
更好的浮点数比较运算应该是容忍一定精度范围

	*code*
	#define NUMBER_LOWPRECISION 1e-8
	#define numeq(a,b) ( (b) - (a) <= NUMBER_LOWPRECISION && \
	                     (b) - (a) >= -NUMBER_LOWPRECISION )
	#define numlt(a,b) ( (b) - (a) > NUMBER_LOWPRECISION )
	#define numle(a,b) ( (b) - (a) >= -NUMBER_LOWPRECISION )

* 浮点数转整数

	*code*
	floor d     返回不大于d的整数
	ceil  d     返回不小于d的整数
	round d     四舍五入

** 使用特定魔数转换

需要使用双精度运算且d的整数部分要能用32位int表示

	*code*
	union _Cast { double l_d; int l_i; };
	#define number2int(i,d) \
	{ volatile union _Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_i; }

解释下原理，先看下这个魔数的浮点数表示

	*code*
	6755399441055744.0 = 1.1 * 2^52
		=0  10000110011  1000000000000000000000000000000000000000000000000000

执行d + 6755399441055744.0，运算器先把d对齐成 ±0.000...xxx * 2^52，尾数部分再四舍五入保留52位；
效果就是d的小数部分四舍五入没了，尾数变成 0_(20位)_xxx_(32位)，可以发现 ±xxx_(32位)就是需要的整数。
尾数部分 10_(51位) ± 0_(20位)xxx_(32位)得到值的后32位就是±xxx_(32位)的补码表示，直接取用就行。

